<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java8集合框架新增方法汇总"><meta name="keywords" content="Java,Lambda"><meta name="author" content="Folgerjun,undefined"><meta name="copyright" content="Folgerjun"><title>Java8集合框架新增方法汇总 | DoubleFJ の Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.4"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7aad83bb2e8992c6c6479f56e988e5b7";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"LQFV2HSBA9","apiKey":"1abe86b5af2a3a59af2ef30373411d90","indexName":"my-blog","hits":{"per_page":10},"labels":{"input_placeholder":"search what ?","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection"><span class="toc-number">1.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-number">1.1.</span> <span class="toc-text">forEach()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeIf"><span class="toc-number">1.2.</span> <span class="toc-text">removeIf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replaceAll"><span class="toc-number">1.3.</span> <span class="toc-text">replaceAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">1.4.</span> <span class="toc-text">sort()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spliterator"><span class="toc-number">1.5.</span> <span class="toc-text">spliterator()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream-parallelStream"><span class="toc-number">1.6.</span> <span class="toc-text">stream() / parallelStream()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">2.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach-1"><span class="toc-number">2.1.</span> <span class="toc-text">forEach()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getOrDefault"><span class="toc-number">2.2.</span> <span class="toc-text">getOrDefault()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putIfAbsent"><span class="toc-number">2.3.</span> <span class="toc-text">putIfAbsent()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove"><span class="toc-number">2.4.</span> <span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replace"><span class="toc-number">2.5.</span> <span class="toc-text">replace()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replaceAll-1"><span class="toc-number">2.6.</span> <span class="toc-text">replaceAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge"><span class="toc-number">2.7.</span> <span class="toc-text">merge()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compute"><span class="toc-number">2.8.</span> <span class="toc-text">compute()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computeIfAbsent"><span class="toc-number">2.9.</span> <span class="toc-text">computeIfAbsent()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computeIfPresent"><span class="toc-number">2.10.</span> <span class="toc-text">computeIfPresent()</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars3.githubusercontent.com/u/24917694?s=460&amp;v=4"></div><div class="author-info__name text-center">Folgerjun</div><div class="author-info__description text-center">DoubleFJ の Blog</div><div class="follow-button"><a href="https://github.com/Folgerjun" target="_blank">follow ?</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">19</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://lay.putop.top" target="_blank">lay.putop.top</a><a class="author-info-links__name text-center" href="http://face.putop.top" target="_blank">face.putop.top</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">DoubleFJ の Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Java8集合框架新增方法汇总</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/开发/">开发</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/开发/总结/">总结</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3,499</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><blockquote>
<p>本想着自己总结记录汇总下这些新方法的，结果一搜，一点，乖乖，真的是太详细了，然后我就搬过来了。。<a href="https://www.cnblogs.com/CarpenterLee/p/6507161.html" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<p>其中当然也涉及Lambda表达式，简化代码，何乐不为。</p>
<hr>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>,作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么不重要，甚至不需要记住它的名字）。</p>
<p><strong>需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串</strong></p>
<p>Java7及以前我们可以用增强的for循环实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 使用曾强for循环迭代</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">for(String str : list) &#123;</span><br><span class="line">    if(str.length() &gt; 3)</span><br><span class="line">        System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在使用forEach()方法结合匿名内部类，可以这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用forEach()结合匿名内部类迭代</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">list.forEach(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String str) &#123;</span><br><span class="line">        if(str.length() &gt; 3)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 使用forEach()结合Lambda表达式迭代</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        if(str.length() &gt; 3)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，<strong>类型推导帮我们做了一切</strong>。</p>
<h3 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h3><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>,作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Perdicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>
<p><strong>需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</strong></p>
<p>我们知道如果需要在迭代过程中对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用迭代器删除列表元素</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">while(it.hasNext()) &#123;</span><br><span class="line">    if(it.next().length() &gt; 3) // 删除长度大于3的元素</span><br><span class="line">        it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可以这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用removeIf()结合匿名名内部类实现</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">list.removeIf(new Predicate&lt;String&gt;() &#123; // 删除长度大于3的元素</span><br><span class="line">    @Override</span><br><span class="line">    public boolean test(String str) &#123;</span><br><span class="line">        return str.length() &gt; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用removeIf()结合Lambda表达式实现</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">list.removeIf(str -&gt; str.length() &gt; 3); // 删除长度大于3的元素</span><br></pre></td></tr></table></figure></p>
<p>使用Lambda表达式不需要记住<code>Predicate</code>接口名，也不需要记住<code>test()</code>方法名，只需要知道此处需要返回一个boolean类型的Lambda表达式就行了。</p>
<h3 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h3><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素。</strong>其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>
<p><strong>需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</strong></p>
<p>Java7及之前似乎没有优雅的办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用下标实现元素替换</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">for (int i=0; i&lt;list.size(); i++) &#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    if (str.length() &gt; 3)</span><br><span class="line">        list.set(i, str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用匿名内部类实现</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">list.replaceAll(new UnaryOperator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(String str) &#123;</span><br><span class="line">        if(str.length() &gt; 3)</span><br><span class="line">            return str.toUpperCase();</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用Lambda表达式实现</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    if(str.length() &gt; 3)</span><br><span class="line">        return str.toUpperCase();</span><br><span class="line">    return str;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序。</strong><code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, To2)</code>需要实现，显然该接口是个函数接口。</p>
<p><strong>需求：假设有一个字符串列表，按照字符串长度增序对元素排序。</strong></p>
<p>由于Java7以及之前<code>sort()</code>方法在<code>Collections</code>工具类，所以代码要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Collections.sort()方法</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String str1, String str2) &#123;</span><br><span class="line">        return str1.length() - str2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>现在可以直接使用<code>List.sort()</code>方法，结合Lambda表达式，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// List.sort()方法结合Lambda表达式</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length() - str2.length());</span><br></pre></td></tr></table></figure></p>
<h3 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h3><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>
<ul>
<li><code>Spliterator</code>即可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>
<li><code>Spliterator</code>是可以拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>
</ul>
<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>
<h3 id="stream-parallelStream"><a href="#stream-parallelStream" class="headerlink" title="stream() / parallelStream()"></a>stream() / parallelStream()</h3><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回容器的<code>stream</code>视图表示，</strong>不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。<strong><code>Stream</code>是Java函数式编程的核心类，我之前也有<a href="http://putop.top/2018/07/13/stream-jdk1.8/">文章</a>详细介绍过</strong>。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>相比<code>Collection</code>，<code>Map</code>中加入了更多的方法，我们以<code>HashMap</code>为例来逐一探秘。</p>
<h3 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h3><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code>，作用是<strong>对<code>Map</code>中每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，不须记住。</p>
<p><strong>需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系</strong></p>
<p>Java7以及之前经典的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Java7以及之前迭代Map</span><br><span class="line">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;one&quot;);</span><br><span class="line">map.put(2, &quot;two&quot;);</span><br><span class="line">map.put(3, &quot;three&quot;);</span><br><span class="line">for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Map.forEach()</code> 方法，结合匿名内部类，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用forEach()结合匿名内部类迭代Map</span><br><span class="line">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;one&quot;);</span><br><span class="line">map.put(2, &quot;two&quot;);</span><br><span class="line">map.put(3, &quot;three&quot;);</span><br><span class="line">map.forEach(new BiConsumer&lt;Integer, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer k, String v) &#123;</span><br><span class="line">        System.out.println(k + &quot;=&quot; + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用forEach()结合Lambda表达式迭代Map</span><br><span class="line">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;one&quot;);</span><br><span class="line">map.put(2, &quot;two&quot;);</span><br><span class="line">map.put(3, &quot;three&quot;);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + &quot;=&quot; + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是<strong>按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code></strong>。使用该方法程序员可以省去查询指定键值是否存在的麻烦。</p>
<p><strong>需求：假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 查询Map中指定的值，不存在时使用默认值</span><br><span class="line">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;one&quot;);</span><br><span class="line">map.put(2, &quot;two&quot;);</span><br><span class="line">map.put(3, &quot;three&quot;);</span><br><span class="line">// Java7以及之前做法</span><br><span class="line">if (map.containsKey(4)) &#123; // 1</span><br><span class="line">    System.out.println(map.get(4));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;NoValue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// Java8使用Map.getOrDefault()</span><br><span class="line">System.out.println(map.getOrDefault(4, &quot;NoValue&quot;)); // 2</span><br></pre></td></tr></table></figure></p>
<h3 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为null时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改。该方法将条件判断和赋值合二为一，使用起来更加方便。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中<strong><code>key</code>正好映射到<code>value</code>时</strong>才删除该映射，否则什么也不做。</p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>在Java7及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法来实现，该方法总是会用新值替换原来的值，为了更精确的控制替换行为，Java8在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>
<ul>
<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中<strong><code>key</code>的映射存在时</strong>才用<code>value</code>去替换原来的值，否则什么也不做。</li>
<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中<strong><code>key</code>的映射存在且等于<code>oldValue</code>时</strong>才用<code>newValue</code>去替换原来的值，否则什么也不做。</li>
</ul>
<h3 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h3><p>该方法签名为<code>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>，不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字。</p>
<p><strong>需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写</strong></p>
<p>Java7以及之前经典的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Java7以及之前替换所有Map中所有映射关系</span><br><span class="line">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;one&quot;);</span><br><span class="line">map.put(2, &quot;two&quot;);</span><br><span class="line">map.put(3, &quot;three&quot;);</span><br><span class="line">for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用replaceAll()结合匿名内部类实现</span><br><span class="line">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;one&quot;);</span><br><span class="line">map.put(2, &quot;two&quot;);</span><br><span class="line">map.put(3, &quot;three&quot;);</span><br><span class="line">map.replaceAll(new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer k, String v) &#123;</span><br><span class="line">        return v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 使用replaceAll()结合Lambda表达式实现</span><br><span class="line">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;one&quot;);</span><br><span class="line">map.put(2, &quot;two&quot;);</span><br><span class="line">map.put(3, &quot;three&quot;);</span><br><span class="line">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure></p>
<p>简洁到让人难以置信。</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h3><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code>，作用是：</p>
<ul>
<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>
<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射。</li>
</ul>
<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>。<code>merge()</code>方法虽然语义有些复杂，但该方法的用法很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.merge(key, newMeg, (v1, v2) -&gt; v1 + v2);</span><br></pre></td></tr></table></figure></p>
<h3 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h3><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，作用是<strong>把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射</strong>。</p>
<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.compute(key, (k, v) -&gt; v == null ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure></p>
<h3 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h3><p>该方法签名为<code>v computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</code>，作用是：<strong>只有在当前<code>Map</code>中不存在<code>key</code>值的映射或映射值为<code>null</code>时，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联</strong>。</p>
<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>。</p>
<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射，比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map&lt;K, Set&lt;V&gt;&gt;</code>，要向<code>Map</code>中放入新值，可通过如下代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">// Java7及以前的实现方式</span><br><span class="line">if (map.containsKey(1))&#123;</span><br><span class="line">    map.get(1).add(&quot;one&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = new HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(&quot;one&quot;);</span><br><span class="line">    map.put(1, valueSet);</span><br><span class="line">&#125;</span><br><span class="line">// Java8的实现方式</span><br><span class="line">map.computeIfAbsent(1, v -&gt; new HashSet&lt;String&gt;()).add(&quot;yi&quot;);</span><br></pre></td></tr></table></figure></p>
<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更简洁。</p>
<h3 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h3><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，<strong>只有在当前<code>Map</code>中存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射。</p>
<p><em>这个函数的功能跟如下代码是等效的：</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Java7及以前跟computeIfPresent()等效的代码</span><br><span class="line">if (map.get(key) != null) &#123;</span><br><span class="line">    V oldValue = map.get(key);</span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">    if (newValue != null)</span><br><span class="line">        map.put(key, newValue);</span><br><span class="line">    else</span><br><span class="line">        map.remove(key);</span><br><span class="line">    return newValue;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>End.</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Folgerjun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://putop.top/2018/08/17/collections-addF-jdk1.8/">http://putop.top/2018/08/17/collections-addF-jdk1.8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://putop.top" target="_blank">DoubleFJ の Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Lambda/">Lambda</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/08/24/arrcopy-beancopy/"><i class="fa fa-chevron-left">  </i><span>Java中的数组拷贝以及对象Bean拷贝</span></a></div><div class="next-post pull-right"><a href="/2018/08/10/sort-algorithm/"><span>常用排序算法</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'lykH3HaE6LQDaaR68kpFjKtF-gzGzoHsz',
  appKey:'PECt6iawOFxDkcUTOADzboyr',
  placeholder:'Welcome to you, my friend!',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By Folgerjun</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="icp"><a><span>皖ICP备17001794号-2</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.4"></script><script src="/js/fancybox.js?version=1.5.4"></script><script src="/js/sidebar.js?version=1.5.4"></script><script src="/js/copy.js?version=1.5.4"></script><script src="/js/fireworks.js?version=1.5.4"></script><script src="/js/transition.js?version=1.5.4"></script><script src="/js/scroll.js?version=1.5.4"></script><script src="/js/head.js?version=1.5.4"></script></body></html>